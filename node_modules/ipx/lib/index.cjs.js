'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const path = require('path');
const Sharp = require('sharp');
const cron = require('cron');
const consola2 = require('consola');
const defu2 = require('defu');
const isValidPath = require('is-valid-path');
const fsExtra = require('fs-extra');
const http2 = require('http');
const https2 = require('https');
const fetch = require('node-fetch');
const recursiveReadDir = require('recursive-readdir');
const getEtag = require('etag');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const Sharp__default = /*#__PURE__*/_interopDefaultLegacy(Sharp);
const consola2__default = /*#__PURE__*/_interopDefaultLegacy(consola2);
const defu2__default = /*#__PURE__*/_interopDefaultLegacy(defu2);
const isValidPath__default = /*#__PURE__*/_interopDefaultLegacy(isValidPath);
const http2__default = /*#__PURE__*/_interopDefaultLegacy(http2);
const https2__default = /*#__PURE__*/_interopDefaultLegacy(https2);
const fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
const recursiveReadDir__default = /*#__PURE__*/_interopDefaultLegacy(recursiveReadDir);
const getEtag__default = /*#__PURE__*/_interopDefaultLegacy(getEtag);

const MAX_SIZE = 2048;
const argRegex = /^[a-z0-9]+$/i;
const numRegex = /^[1-9][0-9]*$/;
class HttpError extends Error {
  constructor() {
    super(...arguments);
    this.statusCode = 500;
  }
}
function checkConditionalHeaders(req, lastModified, etag) {
  const ifNoneMatch = req.headers["if-none-match"];
  if (ifNoneMatch === etag) {
    return true;
  }
  const ifModifiedSince = req.headers["if-modified-since"];
  if (ifModifiedSince) {
    if (new Date(ifModifiedSince) >= lastModified) {
      return true;
    }
  }
  return false;
}
function badRequest(msg) {
  const err = new HttpError("Bad Request: " + msg);
  err.statusCode = 400;
  return err;
}
function notFound() {
  const err = new HttpError("Not Found");
  err.statusCode = 404;
  return err;
}
const VArg = (arg) => {
  if (!argRegex.test(arg)) {
    throw badRequest("Invalid argument: " + arg);
  }
  return arg;
};
const VMax = (max) => (num) => {
  if (!numRegex.test(num)) {
    throw badRequest("Invalid numeric argument: " + num);
  }
  return Math.min(parseInt(num), max) || null;
};
const VSize = VMax(MAX_SIZE);
const consola = consola2__default['default'].withTag("ipx");

const OPERATIONS = {
  format: {
    name: "format",
    args: [VArg],
    handler: (_context, pipe, format) => pipe.toFormat(format, {
      quality: _context.quality || 80
    })
  },
  s: {
    name: "resize",
    args: [VSize, VSize],
    order: true,
    handler: (_context, pipe, width, height, fit) => pipe.resize(width, height, {
      fit: fit || _context.fit || "cover",
      background: _context.background || {r: 0, g: 0, b: 0, alpha: 0}
    })
  },
  b: {
    name: "background",
    args: [VArg],
    handler: (_context, _pipe, model, background) => {
      if (!background) {
        background = model;
      }
      if (model === "hex") {
        background = "#" + background;
      }
      _context.background = background;
    }
  },
  q: {
    name: "quality",
    args: [VMax(100)],
    handler: (_context, _pipe, quality) => {
      _context.quality = quality;
    }
  },
  f: {
    name: "fit",
    args: [VArg],
    handler: (_context, _pipe, fit) => {
      _context.fit = fit;
    }
  },
  w: {
    name: "width",
    args: [VSize],
    handler: (_context, pipe, width) => pipe.resize(width, null)
  },
  h: {
    name: "height",
    args: [VSize],
    handler: (_context, pipe, height) => pipe.resize(null, height)
  },
  embed: {
    name: "embed",
    args: [],
    handler: (_context, pipe) => pipe.embed()
  },
  max: {
    name: "max",
    args: [],
    handler: (_context, pipe) => pipe.max()
  },
  min: {
    name: "min",
    args: [],
    handler: (_context, pipe) => pipe.min()
  }
};

function env(name, defaultValue) {
  return process.env[name] || defaultValue;
}
const defaults = {
  port: env("IPX_PORT", env("PORT", 3e3)),
  inputs: [],
  cache: {
    adapter: env("IPX_CACHE_ADAPTER", "fs"),
    dir: env("IPX_CACHE_DIR", "cache"),
    cleanCron: env("IPX_CACHE_CLEAN_CRON", "0 0 3 * * *"),
    maxUnusedMinutes: env("IPX_CACHE_CLEAN_MINUTES", 24 * 60)
  },
  sharp: {}
};
function getConfig(options) {
  const config = defu2__default['default'](options, defaults);
  if (!config.inputs.length) {
    config.inputs = [
      {
        name: env("IPX_INPUT_NAME", "local"),
        adapter: env("IPX_INPUT_ADAPTER", "fs"),
        dir: env("IPX_INPUT_DIR", "storage")
      }
    ];
  }
  return config;
}

class BaseInputAdapter {
  constructor(ipx2, options) {
    this.ipx = ipx2;
    this.options = options;
    this.init();
  }
  init() {
  }
  get name() {
    return this.options.name;
  }
}

class FSAdapter extends BaseInputAdapter {
  get dir() {
    return this.options.dir;
  }
  _resolve(src) {
    return path.resolve(this.dir, src);
  }
  async stats(src) {
    if (path.posix.isAbsolute(src) || !isValidPath__default['default'](src)) {
      return false;
    }
    const _src = await this._resolve(src);
    if (path.relative(this.dir, _src).includes("..")) {
      return false;
    }
    try {
      const stats = await fsExtra.stat(_src);
      return stats;
    } catch (e) {
      return false;
    }
  }
  async get(src) {
    const _src = await this._resolve(src);
    const buff = fsExtra.readFile(_src);
    return buff;
  }
}

class RemoteAdapter extends BaseInputAdapter {
  constructor() {
    super(...arguments);
    this.httpsAgent = void 0;
    this.httpAgent = void 0;
  }
  init() {
    this.httpsAgent = new https2__default['default'].Agent({
      keepAlive: true
    });
    this.httpAgent = new http2__default['default'].Agent({
      keepAlive: true
    });
    this.options.accept = this.options.accept || [".*"];
  }
  getAgent(src) {
    return src.startsWith("https") ? this.httpsAgent : this.httpAgent;
  }
  async _retrive(src) {
    var _a, _b, _c, _d;
    const cacheKey = (_a = src.split(/[?#]/).shift()) == null ? void 0 : _a.split("//").pop();
    const cache = await ((_b = this.ipx.cache) == null ? void 0 : _b.get(cacheKey));
    if (cache) {
      return {
        cache: await ((_c = this.ipx.cache) == null ? void 0 : _c.resolve(cacheKey)),
        buffer: cache
      };
    }
    const response = await fetch__default['default'](src, {
      agent: this.getAgent(src)
    });
    const buffer = await response.buffer();
    if (this.ipx.cache) {
      await this.ipx.cache.set(cacheKey, buffer);
    }
    return {
      cache: await ((_d = this.ipx.cache) == null ? void 0 : _d.resolve(cacheKey)),
      buffer
    };
  }
  accept(src) {
    if (!src.startsWith("http")) {
      return false;
    }
    if (!this.options.accept.some((rule) => src.match(rule))) {
      return false;
    }
    return true;
  }
  async stats(src) {
    if (!this.accept(src)) {
      return false;
    }
    const _src = await this._retrive(src);
    try {
      const stats = await fsExtra.stat(_src.cache);
      return stats;
    } catch (e) {
      return false;
    }
  }
  async get(src) {
    return (await this._retrive(src)).buffer;
  }
}

const InputAdapters = /*#__PURE__*/Object.freeze({
  __proto__: null,
  fs: FSAdapter,
  remote: RemoteAdapter
});

class BaseCacheAdapter {
  constructor(ipx2) {
    this.ipx = ipx2;
    this.options = ipx2.options;
    this.init();
  }
  init() {
  }
}

class FSCache extends BaseCacheAdapter {
  init() {
    if (this.options.cache.dir) {
      fsExtra.mkdirpSync(this.options.cache.dir);
    }
  }
  resolve(key) {
    return path.resolve(this.options.cache.dir, key);
  }
  async clean() {
    const now = new Date();
    const diffMins = (t) => (+now - +t) / (1e3 * 60);
    const files = await recursiveReadDir__default['default'](this.options.cache.dir);
    let items = await Promise.all(files.map(async (file) => {
      const stats = await fsExtra.stat(file);
      return {
        file,
        lastAccessAgo: diffMins(stats.atime)
      };
    }));
    const maxUnusedMinutes = +this.options.cache.maxUnusedMinutes;
    items = items.filter((item) => item.lastAccessAgo >= maxUnusedMinutes);
    await Promise.all(items.map(async (item) => {
      consola2__default['default'].debug("[DELETE] " + item.file);
      await fsExtra.remove(item.file);
    }));
  }
  async get(key) {
    const _path = await this.resolve(key);
    if (!await fsExtra.exists(_path)) {
      return null;
    }
    consola2__default['default'].debug("[HIT] " + key);
    return fsExtra.readFile(_path);
  }
  async set(key, data) {
    const _path = await this.resolve(key);
    await fsExtra.mkdirp(path.dirname(_path));
    return fsExtra.writeFile(_path, data);
  }
}

const CacheAdapters = /*#__PURE__*/Object.freeze({
  __proto__: null,
  fs: FSCache
});

const operationSeparator = ",";
const argSeparator = "_";
const unknownFormat = "unknown";
class IPX {
  constructor(options) {
    this.inputs = [];
    this.options = getConfig(options);
    this.operations = {};
    this.adapter = null;
    this.init();
  }
  init() {
    const _operations = Object.assign({}, OPERATIONS, this.options.operations);
    Object.keys(_operations).filter((_key) => _operations[_key]).forEach((_key) => {
      const operation = _operations[_key];
      const key = _key || operation.key;
      this.operations[key] = {
        name: operation.name || key,
        handler: operation.handler || operation,
        multiply: Boolean(operation.multiply),
        order: Boolean(operation.order),
        args: operation.args || []
      };
    });
    const inputs = this.options.inputs;
    this.initInputs(inputs);
    let CacheCtor;
    if (typeof this.options.cache.adapter === "string") {
      const adapter = this.options.cache.adapter;
      CacheCtor = CacheAdapters[adapter] || require(path.resolve(adapter));
    } else {
      CacheCtor = this.options.cache.adapter;
    }
    this.cache = new CacheCtor(this);
    if (typeof this.cache.init === "function") {
      this.cache.init();
    }
    if (this.options.cache.cleanCron) {
      this.cacheCleanCron = new cron.CronJob(this.options.cache.cleanCron, () => this.cleanCache().catch(consola.error));
      consola.info("Starting cache clean cron " + this.options.cache.cleanCron);
      this.cacheCleanCron.start();
    }
  }
  parseOperations(operations2) {
    const ops = {};
    if (operations2 === "_") {
      return [];
    }
    return operations2.split(operationSeparator).map((_o) => {
      const [key, ...args] = _o.split(argSeparator);
      const operation = this.operations[key];
      if (!operation) {
        throw badRequest("Invalid operation: " + key);
      }
      if (operation.args.length > args.length) {
        throw badRequest("Invalid number of args for " + key + ". Expected " + operation.args.length + " got " + args.length);
      }
      for (let i = 0; i < operation.args.length; i++) {
        args[i] = operation.args[i](args[i]);
      }
      if (!operation.multiply) {
        if (ops[operation.name]) {
          throw badRequest(key + " can be only used once");
        }
        ops[operation.name] = true;
      }
      return {
        operation,
        args,
        cacheKey: key + argSeparator + args.join(argSeparator)
      };
    });
  }
  async getInfo({adapter, format, operations: operations2, src}) {
    if (format === "_") {
      format = path.extname(src).substr(1);
    }
    if (format === "jpeg") {
      format = "jpg";
    }
    if (!format.match(/webp|png|jpg|svg|gif/)) {
      format = unknownFormat;
    }
    if (!src || src.includes("..")) {
      throw notFound();
    }
    const stats = await this.stats(src, adapter);
    if (!stats) {
      throw notFound();
    }
    let _operations = this.parseOperations(operations2);
    _operations = [
      ..._operations.filter((o) => o.operation.order !== true).sort(),
      ..._operations.filter((o) => o.operation.order === true)
    ];
    const operationsKey = _operations.length ? _operations.map((o) => o.cacheKey).join(argSeparator) : "_";
    const statsKey = stats.mtime.getTime().toString(16) + "-" + stats.size.toString(16);
    const cacheKey = src + "/" + statsKey + "/" + operationsKey + "." + format;
    return {
      operations: _operations,
      stats,
      cacheKey,
      adapter,
      format,
      mimeType: this.getMimeType(format),
      src
    };
  }
  applyOperations(sharp2, {operations: operations2, format}) {
    if (format !== unknownFormat) {
      operations2.push({
        operation: this.operations.format,
        args: [format]
      });
    }
    const context = {};
    operations2.forEach(({operation, args}) => {
      sharp2 = operation.handler(context, sharp2, ...args) || sharp2;
    });
    return sharp2;
  }
  async getData(info) {
    const cache = await this.cache.get(info.cacheKey);
    if (cache) {
      return cache;
    }
    let data = await this.get(info.src, info.adapter);
    let sharp2 = Sharp__default['default'](data);
    Object.assign(sharp2.options, this.options.sharp);
    if (!this.skipOperations(info)) {
      sharp2 = this.applyOperations(sharp2, info);
      data = await sharp2.toBuffer();
    }
    try {
      await this.cache.set(info.cacheKey, data);
    } catch (e) {
      consola.error(e);
    }
    return data;
  }
  async cleanCache() {
    if (this.cache) {
      await this.cache.clean();
    }
  }
  initInputs(inputs) {
    this.inputs = inputs.map(({adapter, ...options}) => {
      let InputCtor;
      if (typeof adapter === "string") {
        InputCtor = InputAdapters[adapter] || require(path.resolve(adapter));
      } else {
        InputCtor = adapter;
      }
      const input = new InputCtor(this, options);
      if (typeof input.init === "function") {
        input.init();
      }
      return input;
    });
  }
  async stats(src, adapter) {
    const input = this.inputs.find((inp) => inp.name === adapter);
    if (input) {
      return await input.stats(src);
    }
    return false;
  }
  async get(src, adapter) {
    const input = this.inputs.find((inp) => inp.name === adapter);
    return await input.get(src);
  }
  getMimeType(format) {
    switch (format) {
      case "_":
        return "image";
      case "svg":
        return "image/svg+xml";
      default:
        return "image/" + format;
    }
  }
  skipOperations(info) {
    if (info.format.match(/svg|gif/)) {
      return true;
    }
    return false;
  }
}

async function IPXReqHandler(req, res, ipx2) {
  const url = req.url || "/";
  const urlArgs = url.substr(1).split("/");
  const adapter = decodeURIComponent(urlArgs.shift() || "");
  const format = decodeURIComponent(urlArgs.shift() || "");
  const operations = decodeURIComponent(urlArgs.shift() || "");
  const src = urlArgs.map((c) => decodeURIComponent(c)).join("/");
  if (!adapter) {
    throw badRequest("Missing adapter");
  }
  if (!format) {
    throw badRequest("Missing format");
  }
  if (!operations) {
    throw badRequest("Missing operations");
  }
  if (!src) {
    throw badRequest("Missing src");
  }
  const info = await ipx2.getInfo({adapter, format, operations, src});
  res.setHeader("Content-Type", info.mimeType);
  const etag2 = getEtag__default['default'](info.cacheKey);
  res.setHeader("Etag", etag2);
  if (info.stats) {
    const lastModified = info.stats.mtime || new Date();
    res.setHeader("Last-Modified", +lastModified);
    if (checkConditionalHeaders(req, lastModified, etag2)) {
      res.statusCode = 304;
      return res.end();
    }
  }
  const data = await ipx2.getData(info);
  res.end(data);
}
function IPXMiddleware(ipx2) {
  return function IPXMiddleware2(req, res) {
    IPXReqHandler(req, res, ipx2).catch((err) => {
      if (err.statusCode) {
        res.statusCode = err.statusCode;
      }
      res.end("IPX Error: " + err);
    });
  };
}

exports.IPX = IPX;
exports.IPXMiddleware = IPXMiddleware;
